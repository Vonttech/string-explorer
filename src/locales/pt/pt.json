{
  "meta": {
  "longName": "Portugu√™s",
  "author": "kevenndc"
  },
  "labels": {
    "language": "Idioma",
    "firstSelectLabel": "Eu tenho uma string, eu gostaria de",
    "seeDocs": "veja a documenta√ß√£o",
    "example": "Exemplo",
    "output": "Resultado",
    "methodTypes": {
      "add": {
        "optionLabel": "adicionar algo",
        "selectedLabel": "Eu quero adicionar"
      },
      "remove": {
        "optionLabel": "remover algo",
        "selectedLabel": "Eu quero remover"
      },
      "replace": {
        "optionLabel": "substituir algo",
        "selectedLabel": "Eu quero substituir"
      },
      "get": {
        "optionLabel": "obter uma parte dela",
        "selectedLabel": "Eu quero obter"
      },
      "has": {
        "optionLabel": "saber se ela possui um texto espec√≠fico",
        "selectedLabel": "Eu quero saber se"
      },
      "findChar": {
        "optionLabel": "encontrar algo em um √≠ndice espec√≠fico",
        "selectedLabel": "Eu tenho um √≠ndice e quero encontrar"
      },
      "findIndex": {
        "optionLabel": "encontrar o √≠ndice de um texto na string",
        "selectedLabel": "Eu tenho um texto e quero saber"
      },
      
      "convert": {
        "optionLabel": "converter",
        "selectedLabel": "Eu quero converter"
      }
      
    }
  },
  "methods": {
    "add": {
      "concat": {
        "optionLabel": "um ou mais textos √† string",
        "description": "Retorna uma nova string com o texto da string original concatenado com os textos passados como argumento.",
        "example": "const code = 'C√≥digo'; \n console.log(code.concat(' √© ', 'poesia');",
        "output": "\"C√≥digo √© poesia\""
      },
      "repeat": {
        "optionLabel": "c√≥pias repetidas da mesma string",
        "description": "Retorna uma nova string com o texto original da string repetido um determinado n√∫mero de vezes.",
        "example": "const abc = 'Abc'; \n console.log(abc.repeat(3));",
        "output": "\"AbcAbcAbc\""
      },
      "padStart": {
        "optionLabel": "um texto se repetindo no in√≠cio da string",
        "description": "Retorna uma nova string com um mesmo texto se repetindo no in√≠cio da string at√© ela atingir um tamanho limite determinado.",
        "example": "const lastDigits = '5834'; \n const maskedNumber = lastDigits.padStart(16, '*'); \n console.log(maskedNumber);",
        "output": "\"************5834\""
      },
      "padEnd": {
        "optionLabel": "um texto se repetindo no final da string",
        "description": "Retorna uma nova string com um mesmo texto se repetindo no final da string at√© ela atingir um tamanho limite determinado.",
        "example": "const firstDigits = '0896'; \n const maskedNumber = firstDigits.padEnd(16, '*') \n console.log(maskedNumber);",
        "output": "\"0896************\""
      } 
    },
    "remove": {
      "trim": {
        "optionLabel": "todos os espa√ßos em branco da string",
        "description": "Retorna uma nova string com todos os espa√ßos em branco removidos.",
        "example": "const phoneNumber = ' 12 3456 7890 '; \n console.log(phoneNumber.trim());",
        "output": "\"1234567890\""
      },
      "trimStart": {
        "optionLabel": "todos os espa√ßos em branco no in√≠cio da string",
        "description": "Retorna uma nova string com todos os espa√ßos em branco removidos no √≠nicio da string.",
        "example": "const text = '  Ol√° mundo!  '; \n console.log(text.trimStart());",
        "output": "\"Ol√° mundo!  \""
      },
      "trimEnd": {
        "optionLabel": "todos os espa√ßos em branco no final da string",
        "description": "Retorna uma nova string com todos os espa√ßos em branco removidos no final da string",
        "example": "const text = '  Ol√° mundo!  '; \n console.log(text.trimEnd());",
        "output": "\"  Ol√° mundo!\""
      },
      "replace": {
        "optionLabel": "a primeira ocorr√™ncia de um texto ou express√£o regular",
        "description": "Retorna uma nova string com a primeira ocorr√™ncia de um texto ou express√£o regular substitu√≠da por outro texto determinado. Esse m√©todo tamb√©m pode ser usado para remover a ocorr√™ncia ao passar uma string vazia para substitu√≠-la.",
        "example": "const paragraph = 'Ol√° mundo!'; \n console.log(paragraph.replace(' mundo', '');",
        "output": "\"Ol√°!\""
      },
      "replaceAll": {
        "optionLabel": "todas as ocorr√™ncias de um texto ou express√£o regular",
        "description": "Retorna uma nova string com todas as ocorr√™ncias de um texto ou express√£o regular substitu√≠das por outro texto determinado. Esse m√©todo tamb√©m pode ser usado para remover as ocorr√™ncias ao passar uma string vazia para substitu√≠-las.",
        "example": "const id = '123.456.789.00'; \n console.log(id.replaceAll('.', '');",
        "output": "\"12345678900\""
      }
    },
    "replace": {
      "replace": {
        "optionLabel": "a primeira ocorr√™ncia de um texto ou express√£o regular",
        "description": "Retorna uma nova string com a primeira ocorr√™ncia de um texto ou express√£o regular substitu√≠da por outro texto determinado.",
        "example": "const paragraph = 'C√≥digo √© poesia'; \n console.log(paragraph.replace('poesia', 'arte');",
        "output": "\"C√≥digo √© arte\""
      },
      "replaceAll": {
        "optionLabel": "todas as ocorr√™ncias de um texto ou express√£o regular",
        "description": "Retorna uma nova string com todas as ocorr√™ncias de um texto ou express√£o regular substitu√≠das por outro texto determinado.",
        "example": "const date = '26/01/2021'; \n console.log(paragraph.replaceAll('/', '-');",
        "output": "\"26-01-2021\""
      }
    },
    "get": {
      "match": {
        "optionLabel": "todas as ocorr√™ncias de uma express√£o regular",
        "description": "Retorna um array com todas as ocorr√™ncias da express√£o regular na string.",
        "example": "const paragraph = 'Ol√° Mundo!'; \n const regex = /[A-Z]/g; \n console.log(paragraph.match(regex));",
        "output": "[\"O\", \"M\"]"
      },
      "matchAll": {
        "optionLabel": "todas as ocorr√™ncias de uma express√£o regular, incluindo grupos",
        "description": "Retorna um iterados com todas as ocorr√™ncias da express√£o regular, incluindo as ocorr√™ncias de grupos de captura.",
        "example": "const regex = /t(e)(st(\\d?))/g; \n const str = 'test1test2'; \n const array = [...str.matchAll(regex)]; \n console.log(array[0]);",
        "output": "[\"test1\", \"e\", \"st1\", \"1\"]"
      },
      "slice": {
        "optionLabel": "uma parte da string a come√ßar por uma √≠ndice",
        "description": "Retorna uma nova string com todo o texto encontrado a partir de um determinado √≠ndice.",
        "example": "const paragraph = 'C√≥digo √© poesia'; \n console.log(paragraph.slice(7)); \n console.log(paragraph.slice(-6));",
        "output": "\"√© poesia\" \n \"poesia\""
      },
      "substring": {
        "optionLabel": "uma parte da string entre dois √≠ndices",
        "description": "Retorna uma nova string com todo o texto encontrado entre dois √≠ndices determinados.",
        "example": "const paragraph = 'C√≥digo √© poesia'; \n console.log(paragraph.substring(0, 8)); \n console.log(paragraph.substring(9, 15));",
        "output": "\"C√≥digo √©\" \n \"poesia\""
      }
    },
    "has": {
      "includes": {
        "optionLabel": "a string cont√©m um texto espec√≠fico",
        "description": "Retorna <code>true</code> ou <code>false</code> se uma string incluir o texto especificado.",
        "example": "const paragraph = 'C√≥digo √© poesia'; \n console.log(paragraph.includes('C√≥digo')); \n console.log(paragraph.includes('ol√°'));",
        "output": "true \n false"
      },
      "startsWith": {
        "optionLabel": "a string come√ßa com um texto espec√≠fico",
        "description": "Retorna <code>true</code> ou <code>false</code> se uma string come√ßar com os caracteres determinados.",
        "example": "const paragraph = 'C√≥digo √© poesia'; \n console.log(paragraph.startsWith('C√≥digo')); \n console.log(paragraph.startsWith('poesia'));",
        "output": "true \n false"
      },
      "endsWith": {
        "optionLabel": "a string termina com um texto espec√≠fico",
        "description": "Retorna <code>true</code> ou <code>false</code> se uma string terminar com os caracteres determinados.",
        "example": "const paragraph = 'C√≥digo √© poesia'; \n console.log(paragraph.endsWith('c√≥digo')); \n console.log(paragraph.endsWith('poesia'));",
        "output": "false \n true"
      }
    },
    "findChar": {
      "charAt": {
        "optionLabel": "o caractere no √≠ndice especificado",
        "description": "Retorna o caractere encontrado em um determinado √≠ndice da string.",
        "example": "const paragraph = 'C√≥digo √© poesia'; \n const index = 2; \n console.log(`O caractere no √≠ndice ${index} √© ${paragraph.charAt(index)}`);",
        "output": "\"O caractere no √≠ndice 2 √© d\""
      },
      "codePointAt": {
        "optionLabel": "o c√≥digo unicode do caractere no √≠ndice especificado",
        "description": "Retorna o c√≥digo unicode de um caractere em um √≠ndice espec√≠fico.",
        "example": "const hello = 'Ol√° mundo! üòé'; \n console.log('üòé = ' + hello.codePointAt(11));",
        "output": "\"üòé = 128526\""
      }
    },
    "findIndex": {
      "indexOf": {
        "optionLabel": "onde est√° a primeira ocorr√™ncia do texto",
        "description": "Retorna o √≠ndice da primeira ocorr√™ncia de um determinado texto em uma string.",
        "example": "const paragraph = 'C√≥digo √© poesia'; \n console.log(paragraph.indexOf('d'));",
        "output": "2"
      },
      "lastIndexOf": {
        "optionLabel": "onde est√° a √∫ltima ocorr√™ncia do texto",
        "description": "Retorna o √≠ndice da √∫ltima ocorr√™ncia de um determinado texto em uma string.",
        "example": "const paragraph = 'C√≥digo √© poesia'; \n console.log(paragraph.lastIndexOf('o'));",
        "output": "10"
      },
      "search": {
        "optionLabel": "onde est√° a ocorr√™ncia de uma express√£o regular",
        "description": "Retorna o primeiro √≠ndice da ocorr√™ncia de uma express√£o regular na string.",
        "example": "const paragraph = 'itens: item1 item2 item3'; \n console.log(paragraph.search(/item[1-9]/g));",
        "output": "7"
      }
    },
    "convert": {
      "split": {
        "optionLabel": "a string em um array utilizando um separador",
        "description": "Retorna uma lista de strings encontradas entre o texto espec√≠ficado como separador.",
        "example": "const date = '26/01/2021'; \n const dateArr = date.split('/'); \n console.log(dateArr);",
        "output": "[\"26\", \"01\", \"2021\"]"
      },
      "fromCodePoint": {
        "optionLabel": "um c√≥digo Unicode em texto",
        "description": "Retorna uma string criada utilizando a sequ√™ncia de c√≥digos especificada.",
        "example": "console.log(String.fromCodePoint(79, 108, 225, 33, 129312));",
        "output": "\"Ol√°!ü§†\""
      },
      "toUpperCase": {
        "optionLabel": "todo texto para caixa alta",
        "description": "Retorna uma nova string com todo o texto convertido para caixa alta.",
        "example": "const hello = 'Ol√° mundo!'; \n console.log(hello.toUpperCase());",
        "output": "\"OL√Å MUNDO!\""
      },
      "toLowerCase": {
        "optionLabel": "todo texto para caixa baixa",
        "description": "Retorna uma nova string com todo o texto convertido para caixa baixa.",
        "example": "const hello = 'Ol√° mundo!'; \n console.log(hello.toLowerCase());",
        "output": "\"ol√° mundo!\""
      }
    }
  }
}